### 1.scrapy的基本结构(五个部分是什么,请求发出去的整个流程)
>>>
    Scrapy Engine
    引擎负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。 详细内容查看下面的数据流(Data Flow)部分。
    
    调度器(Scheduler)
    调度器从引擎接受request并将他们入队，以便之后引擎请求他们时提供给引擎。
    
    下载器(Downloader)
    下载器负责获取页面数据并提供给引擎，而后提供给spider。
    
    Spiders
    Spider是Scrapy用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。 每个spider负责处理一个特定(或一些)网站。 更多内容请看 Spiders 。
    
    Item Pipeline
    Item Pipeline负责处理被spider提取出来的item。典型的处理有清理、 验证及持久化(例如存取到数据库中)。 更多内容查看 Item Pipeline 。
    
    下载器中间件(Downloader middlewares)
    下载器中间件是在引擎及下载器之间的特定钩子(specific hook)，处理Downloader传递给引擎的response。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。更多内容请看 下载器中间件(Downloader Middleware) 。
    
    Spider中间件(Spider middlewares)
    Spider中间件是在引擎及Spider之间的特定钩子(specific hook)，处理spider的输入(response)和输出(items及requests)。 其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。更多内容请看 Spider中间件(Middleware) 。
    数据流(Data flow)
    Scrapy中的数据流由执行引擎控制，其过程如下:
    
    引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该spider请求第一个要爬取的URL(s)。
    引擎从Spider中获取到第一个要爬取的URL并在调度器(Scheduler)以Request调度。
    引擎向调度器请求下一个要爬取的URL。
    调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件(请求(request)方向)转发给下载器(Downloader)。
    一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件(返回(response)方向)发送给引擎。
    引擎从下载器中接收到Response并通过Spider中间件(输入方向)发送给Spider处理。
    Spider处理Response并返回爬取到的Item及(跟进的)新的Request给引擎。
    引擎将(Spider返回的)爬取到的Item给Item Pipeline，将(Spider返回的)Request给调度器。
    (从第二步)重复直到调度器中没有更多地request，引擎关闭该网站。
### 2.scrapy的去重原理(指纹去重到底是什么)
### 3.scrapy中间件有几种类
>>> 
    位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。
    
    爬虫中间件(Spider Middlewares)介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。
    
    调度中间件(Scheduler Middewares)介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。

### 4.scrapy中间件再哪里起作用
### 5.为什么要用到代理
### 6.代理怎么使用(具体代码,请求在什么时候添加的代理)
### 7.代理失效了怎么处理
### 8.登录验证码处理
### 9.爬取速度过快出现的验证码处理
### 10.如何用机器识别验证码
### 11.模拟登录流程
### 12.cookie如何处理
### 13.如何处理网站传参加密的情况
### 14.分布式如何判断爬虫已经停止
### 15.分布式去重原理
### 16.关系型数据库和非关系型数据库的区别
>>> 
    1.关系型数据库通过外键关联来建立表与表之间的关系，

    2.非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定


### 17.爬下来数据你会选择什么存储方式,为什么
### 18.redis如何实现持久化
### 19.mongodb是都支持事务
### 20.python2和python3的区别,如何实现python2代码迁移到python3环境
### 21.python2和python3的编码方式有什么差别
>>> 
    input()和raw_input()
    For循环变量和全局命名空间泄漏, 在 Python 3.x 中 for 循环变量不会再导致命名空间泄漏。
    Python 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。现在， 在 Python 3，我们最终有了 Unicode (utf-8) 字符串，
    整除
    print函数,Python 2 的 print 声明已经被 print() 函数取代了
    Python 3.x 介绍的 一些Python 2 不兼容的关键字和特性可以通过在 Python 2 的内置 __future__ 模块导入
### 22.主要使用什么样的结构化数据提取方式
### 23.动态加载的数据如何获取
### 24.Celery - 分布式任务队列
>>> 
    专注于实时处理的任务队列，同时也支持任务调度。
    
### 25.__new__和__init__的区别
>>> 
    1.__new__是一个静态方法,而__init__是一个实例方法
    2.__new__方法会返回一个创建的实例,而__init__方法不会
    3.只有在__new__返回一个cls的实例后面的__init__才能被调用.
    4.当创建一个新实例时调用__new__,初始化一个实例时用__init__

### 26.实现方法A的装饰器timeout,5秒之后如果A还没有运行完毕,则抛出异常
>>> 
```python
import signal
import functools


class TimeoutError(Exception):
    pass


def timeout(seconds, error_message="Timeout Error: the cmd 30s have not finished."):
    def decorated(func):
        result = ""

        def _handle_timeout(signum, frame):
            global result
            result = error_message
            raise TimeoutError(error_message)

        def wrapper(*args, **kwargs):
            global result
            signal.signal(signal.SIGALRM, _handle_timeout)
            signal.alarm(seconds)

            try:
                result = func(*args, **kwargs)
            finally:
                signal.alarm(0)
                return result
            # return result

        return functools.wraps(func)(wrapper)

    return decorated


@timeout(3)  # 限定下面的slowfunc函数如果在5s内不返回就强制抛TimeoutError Exception结束
def slowfunc(sleep_time):
    a = 1
    import time
    time.sleep(sleep_time)
    return a


# slowfunc(3) #sleep 3秒，正常返回 没有异常


print(slowfunc(11)) # 被终止)

```
### 27.SSL/TLS的基本过程
>>> 
    SSL/TLS协议的基本思路是采用公钥加密法，

    （1） 客户端向服务器端索要并验证公钥。
    （2） 双方协商生成"对话密钥"。
    （3） 双方采用"对话密钥"进行加密通信。
### 28.简述网关,SNAT和DNAT分别有什么作用
>>>

    SNAT：源地址转换，是Linux防火墙的一种地址转换操作，也是iptables命令中的一种数据包控制类型，其作用是根据指定条件修改数据包的源IP地址。
    DNAT：目标地址转换，是Linux防火墙的另一种地址转换操作，同样也是iptables命令中的一种数据包控制类型，其作用是根据指定条件修改数据包的目标IP地址，目标端口。

### 29.正则提取a标签里的href属性
>>> 
    <a href=[\"|\']?(.*?)[\"|']
 
### 30.SVN和GIT的差别
>>>
    SVN属于集中化的版本控制系统，Git是一个分布式版本控制系统.
    在Git 中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网。
    SVN 断开网络或者断开VPN就无法commit代码，但是Git 可以先commit到本地仓库。
    Git 的内容完整性要优于SVN。
    Git 克隆一个完整项目的速度非常快，SVN 非常慢。
    